9c9
< from asgiref.sync import sync_to_async
---
> import logging
11c11,13
< class GameConsumer(AsyncWebsocketConsumer):
---
> logger = logging.getLogger(__name__)
> 
> class Rps(AsyncWebsocketConsumer):
16,19c18,21
<         self.user = self.scope['user']
<         self.room_name = self.scope["url_route"]["kwargs"]["id"]
< 
<         self.room_group_name = f'game_{self.room_name}'
---
>         try:
>             self.user = self.scope['user']
>             self.room_name = self.scope["url_route"]["kwargs"]["id"]
>             self.room_group_name = f'game_{self.room_name}'
21,23c23,26
<         if not self.is_part_of_the_game(self.user, self.room_name):
<             await self.close()
<             return
---
>             # Additional validation checks
>             if not self.user.is_authenticated:
>                 await self.close()
>                 return
25,32c28,31
<         if not self.user.is_authenticated:
<             await self.close()
<             return
<         
<         await self.accept()
<         if self.user.username in self.act_ply:
<             await self.close()
<             return
---
>             # Check if user is already in an active game
>             if self.user.username in self.act_ply:
>                 await self.close()
>                 return
34,47c33,37
<         if self.room_name not in self.rooms:
<             self.rooms[self.room_name] = {
<                 'game_state': {
<                     'ball': {'x': 250, 'y': 365, 'dx': 5, 'dy': 5},
<                     'paddles': {'up': 180, 'down': 180},
<                     'score': {'p1': 0, 'p2': 0},
<                     'side': {'up': None, 'down': None},
<                     'winner' : None,
<                 },
<                 'players': {
<                     'up': None,
<                     'down': None,
<                 },
<             }
---
>             # Verify user is part of the game choice
>             is_part_of_game = await self.is_part_of_the_game(self.user, self.room_name)
>             if not is_part_of_game:
>                 await self.close()
>                 return
49c39
<         self.act_ply[self.user.username] = self.room_name
---
>             await self.accept()
51,54c41,64
<         await self.channel_layer.group_add(
<             self.room_group_name,
<             self.channel_name,
<         )
---
>             # Initialize room if not exists
>             if self.room_name not in self.rooms:
>                 self.rooms[self.room_name] = {
>                     'game_state': {
>                         'right_choice': None,
>                         'left_choice': None,
>                         'score': {'p1': 0, 'p2': 0},
>                         'winner': None,
>                         'draw': False,
>                         'right_player': None,
>                         'left_player': None,
>                     },
>                     'players': {
>                         'right': None,
>                         'left': None,
>                     },
>                 }
> 
>             self.act_ply[self.user.username] = self.room_name
> 
>             await self.channel_layer.group_add(
>                 self.room_group_name,
>                 self.channel_name,
>             )
56,60c66,90
<         room = self.rooms[self.room_name]
<         game_state = room["game_state"]
<         try:
<             self.match = await self.get_the_game_by_id(self.room_name)
<             if not self.match:
---
>             room = self.rooms[self.room_name]
>             try:
>                 self.match = await self.get_the_game_by_id(self.room_name)
>                 if not self.match:
>                     await self.close()
>                     return
> 
>                 # Assign player position
>                 if self.match.player1 == self.user.username:
>                     if room['players']['right'] is None:
>                         room['players']['right'] = self.user
>                         room['game_state']['right_player'] = self.user.username
> 
>                 elif self.match.player2 == self.user.username:
>                     if room['players']['left'] is None:
>                         room['players']['left'] = self.user
>                         room['game_state']['left_player'] = self.user.username
> 
>                 # Check if game is already completed
>                 if self.match.status == 2:
>                     await self.close()
>                     return
>                 
>             except Exception as e:
>                 logger.error(f"Error in connect method: {e}")
63,70d92
<             if self.match.player1 == self.user.username:
<                 if room['players']['up'] is None:
<                     room['players']['up'] = self.user
<                     game_state["side"]["up"] = room['players']['up'].username
<             elif self.match.player2 == self.user.username:
<                 if room['players']['down'] is None:
<                     room['players']['down'] = self.user
<                     game_state["side"]["down"] = room['players']['down'].username
72,76c94,98
<             # -------------------------
<             if self.match.status == 2:
<                 await self.close()
<                 return
<             
---
>             # Start game loop if both players are present
>             if room['players']['right'] and room['players']['left']:
>                 await self.broadcast_game_state(room['game_state'])
>                 self.game_task = asyncio.create_task(self.game_loop())
> 
77a100
>             logger.error(f"Unexpected error in connect: {e}")
79,82d101
<             return
< 
<         if room['players']['up'] and room['players']['down']:
<             self.game_task = asyncio.create_task(self.game_loop())
84c103,104
<     async def is_part_of_the_game(self, name, id):
---
>     async def is_part_of_the_game(self, user, id):
>         """Verify if the user is part of the game"""
86,90c106,107
<             game:Match = Match.objects.get(id=id)
<             if game.player1 != name and game.player2 != name:
<                 return 1
<         except Match.DoesNotExist:
<             print(f"Match with ID {self.room_name} not found")
---
>             game = await self.get_the_game_by_id(id)
>             return game and (game.player1 == user.username or game.player2 == user.username)
92,93c109,110
<             print(f"Error saving match score: {e}")
<         return 0
---
>             logger.error(f"Error checking game participation: {e}")
>             return False
96a114
>         """Retrieve game by ID"""
102a121
>         """Update match score"""
107a127
>         """Save match score to database"""
109,114c129,136
<             match:Match = Match.objects.get(id=self.room_name)
<             match.player1_score = score1
<             match.player2_score = score2
<             if match.player1_score == 3 or match.player2_score == 3:
<                 match.status = 2
<             match.save()
---
>             with transaction.atomic():
>                 match = Match.objects.select_for_update().get(id=self.room_name)
>                 match.player1_score = score1
>                 match.player2_score = score2
>                 # match.game_type = True
>                 if match.player1_score == 3 or match.player2_score == 3:
>                     match.status = 2
>                 match.save()
116c138
<             print(f"Match with ID {self.room_name}  not found")
---
>             logger.error(f"Match with ID {self.room_name} not found")
118,119c140
<             print(f"Error saving match score: {e}")
< 
---
>             logger.error(f"Error saving match score: {e}")
122a144
>         """Save user updates"""
125,128c147,151
<     async def update_user_after_game(self, winnner, score):
<         if self.user.username == winnner:
<     
<             self.user.total_games += 1
---
>     async def update_user_after_game(self, winner, score):
>         """Update user statistics after game"""
>         self.user.total_games += 1
>         
>         if self.user.username == winner:
131c154
<             self.user.level = math.floor( self.user.points / 1000 ) + 1
---
>             self.user.level = math.floor(self.user.points / 1000) + 1
133,146c156,179
<             if self.user.win_games == 1:
<                 self.user.win_1_game = True
<             if self.user.win_games == 3:
<                 self.user.win_3_games = True
<             if self.user.win_games == 10:
<                 self.user.win_10_games = True
<             if self.user.win_games == 30:
<                 self.user.win_30_games = True
<             if self.user.level > 5:
<                 self.user.reach_level_5 = True
<             if self.user.level > 15:
<                 self.user.reach_level_15 = True
<             if self.user.level > 30:
<                 self.user.reach_level_30 = True
---
>             # Update achievement flags
>             achievement_milestones = [
>                 (1, 'win_1_game'),
>                 (3, 'win_3_games'),
>                 (10, 'win_10_games'),
>                 (30, 'win_30_games')
>             ]
>             
>             for milestone, flag in achievement_milestones:
>                 if self.user.win_games == milestone:
>                     setattr(self.user, flag, True)
>             
>             # Level-based achievements
>             level_milestones = [
>                 (5, 'reach_level_5'),
>                 (15, 'reach_level_15'),
>                 (30, 'reach_level_30')
>             ]
>             
>             for level, flag in level_milestones:
>                 if self.user.level > level:
>                     setattr(self.user, flag, True)
>             
>             # Perfect win
150d182
<             self.user.total_games += 1
152,153c184
<             self.user.level = math.floor( self.user.points / 1000 ) + 1
<                 
---
>         
156d186
< #--------------------------------------------------------------------------------------
157a188,191
>         """Handle disconnection"""
>         try:
>             if self.user.username in self.act_ply:
>                 del self.act_ply[self.user.username]
159,166c193,194
<         if self.user.username in self.act_ply:
<             del self.act_ply[self.user.username]
< 
<         if not self.rooms.get(self.room_name):
<             return
< 
<         room = self.rooms[self.room_name]
<         game_state = room["game_state"]
---
>             if not self.rooms.get(self.room_name):
>                 return
168,181c196,197
<         if not game_state["winner"]:
<             if room['players']['up'] == self.user:
<                 game_state["winner"] = room['players']['down'].username if room['players']['down'] else None
<                 game_state["score"]["p2"] = 3
<                 game_state["score"]["p1"] = 0
<             elif room['players']['down'] == self.user:
<                 game_state["winner"] = room['players']['up'].username if room['players']['up'] else None
<                 game_state["score"]["p1"] = 3
<                 game_state["score"]["p2"] = 0
<             await self.update_match_score(game_state["score"]["p1"], game_state["score"]["p2"])
< 
<         await self.update_user_after_game(game_state["winner"], game_state["score"]["p2"])
<         await self.broadcast_end_game(game_state)
<         await self.channel_layer.group_discard(self.room_group_name, self.channel_name)
---
>             room = self.rooms[self.room_name]
>             game_state = room["game_state"]
183,184c199,221
<         if not any(room['players'].values()):
<             del self.rooms[self.room_name]
---
>             # If game not finished, determine winner based on disconnection
>             if not game_state["winner"]:
>                 if room['players']['right'] == self.user:
>                     game_state["winner"] = room['players']['left'].username if room['players']['left'] else None
>                     game_state["score"]["p2"] = 3
>                     game_state["score"]["p1"] = 0
>                 elif room['players']['left'] == self.user:
>                     game_state["winner"] = room['players']['right'].username if room['players']['right'] else None
>                     game_state["score"]["p1"] = 3
>                     game_state["score"]["p2"] = 0
>                 
>             if not game_state["draw"]:
>                 await self.update_match_score(game_state["score"]["p1"], game_state["score"]["p2"])
>                 await self.update_user_after_game(game_state["winner"], game_state["score"]["p2"])
>             await self.broadcast_end_game(game_state)
>             await self.channel_layer.group_discard(self.room_group_name, self.channel_name)
> 
>             # Clean right room if no players
>             if not any(room['players'].values()):
>                 del self.rooms[self.room_name]
>         
>         except Exception as e:
>             logger.error(f"Error in disconnect: {e}")
186d222
< #--------------------------------------------------------------------------------------
188,216c224,228
<         room = self.rooms[self.room_name]
<         data = json.loads(text_data)
< 
<         if "paddle" in data:
<             paddle = data["paddle"]
< 
<         if self.user == room['players']['up']:
<             if paddle == "upP":
<                 room["game_state"]["paddles"]["up"] = max(
<                     5, min(365, room["game_state"]["paddles"]["up"] - 20)
<                 )
<             elif paddle == "upD":
<                 room["game_state"]["paddles"]["up"] = max(
<                     5, min(365, room["game_state"]["paddles"]["up"] + 20)
<                 )
<         elif self.user == room['players']['down']:
<             if paddle == "upP":
<                 room["game_state"]["paddles"]["down"] = max(
<                     5, min(365, room["game_state"]["paddles"]["down"] - 20)
<                 )
<             elif paddle == "upD":
<                 room["game_state"]["paddles"]["down"] = max(
<                     5, min(365, room["game_state"]["paddles"]["down"] + 20)
<                 )
<             elif paddle == "reset":
<                 room["game_state"]["paddles"]["down"] = 150
<                 room["game_state"]["paddles"]["up"] = 150
<                 await self.reset_ball() 
<         await self.broadcast_game_state()
---
>         """Handle incoming WebSocket messages"""
>         try:
>             room = self.rooms[self.room_name]
>             data = json.loads(text_data)
>             valid_types = {'rock', 'paper', 'scissor'}
218,269c230,246
<     async def ball_moves(self):
<         room = self.rooms[self.room_name]
<         game_state = room["game_state"]
<         game_state["ball"]["x"] += game_state["ball"]["dx"]
<         game_state["ball"]["y"] += game_state["ball"]["dy"]
< 
<         ball_x = game_state["ball"]["x"]
<         ball_y = game_state["ball"]["y"]
<         dx = game_state["ball"]["dx"]
<         dy = game_state["ball"]["dy"]
< 
<         # walls collision
<         if ball_x <= 0 or ball_x >= 490:
<             game_state["ball"]["dx"] = -dx
< 
<         paddle_width = 150
< 
<         # Ball collision (top paddle)
<         if (
<             ball_y <= 27 and
<             ball_x >= game_state["paddles"]["up"] and
<             ball_x <= game_state["paddles"]["up"] + paddle_width
<         ):
<             impact_point = (ball_x - game_state["paddles"]["up"]) / paddle_width - 0.5
<             game_state["ball"]["dx"] += impact_point * 4
<             game_state["ball"]["dy"] = abs(dy)
< 
<         # Ball collision (bott paddle)
<         if (
<             ball_y >= 700 and
<             ball_x >= game_state["paddles"]["down"] and
<             ball_x <= game_state["paddles"]["down"] + paddle_width
<         ):
<             impact_point = (ball_x - game_state["paddles"]["down"]) / paddle_width - 0.5
<             game_state["ball"]["dx"] += impact_point * 4
<             game_state["ball"]["dy"] = -abs(dy)
< 
<         # top player scores
<         if ball_y < 0:
<             game_state["score"]["p2"] += 1
<             await self.reset_ball()
<             if game_state["score"]["p2"] == 3:
<                 game_state["winner"] = room["players"]["down"].username
<             await self.update_match_score(game_state["score"]["p1"], game_state["score"]["p2"])
< 
<         # bott player scores
<         if ball_y > 725:
<             game_state["score"]["p1"] += 1
<             await self.reset_ball()
<             if game_state["score"]["p1"] == 3:
<                 game_state["winner"] = room["players"]["up"].username
<             await self.update_match_score(game_state["score"]["p1"], game_state["score"]["p2"])
---
>             # Validate choice
>             if data['choice'] not in valid_types:
>                 await self.send(text_data=json.dumps({"type": "error", "message": "Invalid type"}))
>                 return
>                 
>             # Set player choice based on position
>             if room['players']['right'] == self.user:
>                 room['game_state']['right_choice'] = data['choice']
>                 
>             if room['players']['left'] == self.user:
>                 room['game_state']['left_choice'] = data['choice']
>                 
>             # Broadcast game state if both players have made a choice
>             
>             if room['game_state']['right_choice'] and room['game_state']['left_choice']:
>                 await self.game_logic()
>                 await self.broadcast_game_state(room['game_state'])
271,279c248,251
<     async def reset_ball(self):
<         room = self.rooms[self.room_name]
<         room["game_state"]["ball"] = {
<             "x": 250,
<             "y": 365,
<             "dx": 5,
<             "dy": 5,
<         }
<         await self.broadcast_game_state()
---
>         except json.JSONDecodeError:
>             await self.send(text_data=json.dumps({"type": "error", "message": "Invalid JSON format"}))
>         except Exception as e:
>             logger.error(f"Error in receive method: {e}")
281c253,254
<     async def broadcast_game_state(self):
---
>     async def broadcast_game_state(self, game_state):
>         """Broadcast current game state to all players"""
287c260
<                 "game_state": room["game_state"],
---
>                 "game_state": game_state,
289a263,266
>         room['game_state']['right_choice'] = None
>         room['game_state']['left_choice'] = None
>         room['game_state']['winner'] = None
>         room['game_state']['draw'] = False
292c269
<         room = self.rooms[self.room_name]
---
>         """Broadcast game end to all players"""
297c274
<                 "game_state": room["game_state"],
---
>                 "game_state": game_state,
302c279,285
<         await self.send(text_data=json.dumps(event))
---
>         """Send game end event to specific player"""
>         response_data = {
>             "type":"game_end",
>             "game_state": event["game_state"]
>         }
>         await self.send(text_data=json.dumps(response_data))
> 
305,306c288,293
<         game_state = event["game_state"]
<         await self.send(text_data=json.dumps(game_state))
---
>         """Send game update to specific player"""
>         response_data = {
>             "type":"game_update",
>             "game_state": event["game_state"]
>         }
>         await self.send(text_data=json.dumps(response_data))
308c295,296
<     async def game_loop(self):
---
>     async def check_player_choice(self):
>         """Wait for both players to make a choice"""
311,312c299
<             if room["game_state"]["score"]["p1"] == 3:
<                 await self.broadcast_end_game(room["game_state"])
---
>             if room['game_state']['right_choice'] and room['game_state']['left_choice']:
314,322c301,344
<             if room["game_state"]["score"]["p2"] == 3:
<                 await self.broadcast_end_game(room["game_state"])
<                 break
<             if room['players']['up'] == None or room['players']['down'] == None:
<                 await self.broadcast_end_game(room["game_state"])
<                 break
<             await self.ball_moves()
<             await self.broadcast_game_state()
<             await asyncio.sleep(0.03)
---
>             await asyncio.sleep(0.1)
> 
>     async def game_logic(self):
>         """Determine game round winner"""
>         win_conditions = {
>             ('rock', 'scissor'),
>             ('scissor', 'paper'),
>             ('paper', 'rock')
>         }
>         
>         room = self.rooms[self.room_name]
>         player_right_choice = room['game_state']['right_choice']
>         player_left_choice = room['game_state']['left_choice']
>         
>         if player_right_choice == player_left_choice:
>             room['game_state']['draw'] = True
>         elif (player_right_choice, player_left_choice) in win_conditions:
>             # room['game_state']['winner'] = room['players']['right'].username
>             room['game_state']['score']['p1'] += 1
>         else:
>             # room['game_state']['winner'] = room['players']['left'].username
>             room['game_state']['score']['p2'] += 1
>             
> 
>     async def game_loop(self):
>         """Main game loop"""
>         try:
>             while True:
>                 room = self.rooms[self.room_name]
>                 # await self.check_player_choice()
>                 # await self.game_logic()
>                 
>                 # Check if game has ended (someone reached 3 points)
>                 if room['game_state']['score']['p1'] >= 3 or room['game_state']['score']['p2'] >= 3:
>                     await self.update_match_score(room['game_state']['score']['p1'], room['game_state']['score']['p2'])
>                     room['game_state']['winner'] = room['players']['right'].username if room['game_state']['score']['p1'] > room['game_state']['score']['p2'] else room['players']['left'].username
> 
>                     await self.broadcast_end_game(room['game_state'])
>                     break
>                 # elif room['game_state']['draw']:
>                 # await self.broadcast_game_state(room['game_state'])
>                 await asyncio.sleep(0.03)
>         except Exception as e:
>             logger.error(f"Error in game loop: {e}")
\ No newline at end of file
